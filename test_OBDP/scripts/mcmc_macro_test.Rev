############################################################################################
#
# RevBayes Validation Test: Occurrence birth-death process
#
# Model: Tree is drawn from a constant-rate fossilized birth-death process with occurrences.
#
#
# authors: Jérémy Andréoletti (from Walker Pett's FBDP test function
#                                   + "Total-evidence dating under the FBD model" tutorial)
#
############################################################################################

seed(12345)

#######################
# Reading in the Data #
#######################

### Read in data

taxa <- readTaxonData("data/data_OBDP/macroevol_taxa.csv")
sequences <- readDiscreteCharacterData("data/data_OBDP/macroevol_seq_extant.nex")
morpho <- readDiscreteCharacterData("data/data_OBDP/macroevol_morpho.nex")
occurrence_ages <- readDataDelimitedFile(file="data/data_OBDP/macroevol_occurrences.csv", delimiter="; ")[1]

# Add Missing Taxa
sequences.addMissingTaxa( taxa )
morpho.addMissingTaxa( taxa )

### Set priors

## Tree-prior distribution : occurrece birth-death process

# OBDP parameters priors
lambda ~ dnExp(10)
mu ~ dnExp(10)
psi ~ dnExp(10)
omega ~ dnExp(5)
rho ~ dnUnif(0.0, 1.0)
rm <- 0.0
N <- 15
# start_time ~ dnUnif(7.7, 12.0)
start_time ~ dnUnif(5.3, 10.0)
useMt <- TRUE
verbose <- FALSE

# Initialise my move index
mvi = 1

# Create some moves that change the stochastic variables
# all moves are sliding proposals but you could use scaling proposals for the rates too
moves[mvi++] = mvScale(lambda, lambda=1.0, weight=1.0, tune=TRUE)
moves[mvi++] = mvScale(mu, lambda=1.0, weight=1.0, tune=TRUE)
moves[mvi++] = mvScale(psi, lambda=1.0, weight=1.0, tune=TRUE)
moves[mvi++] = mvScale(omega, lambda=1.0, weight=1.0, tune=TRUE)

moves[mvi++] = mvSlide(rho, delta=0.1,  weight=1.0, tune=TRUE)
moves[mvi++] = mvSlide(start_time, delta=0.1,  weight=1.0, tune=TRUE)

##############
# Tree prior #
##############

obd_tree ~ dnOBDP(  originAge=start_time,
                    lambda=lambda,
                    mu=mu,
                    psi=psi,
                    omega=omega,
                    rho=rho,
                    r=rm,
                    maxHiddenLin=N,
                    taxa=taxa,
                    occurrence_ages=occurrence_ages,
                    useMt=useMt,
                    verbose=verbose)


moves[mvi++] = mvFNPR(obd_tree, weight=20.0)
moves[mvi++] = mvCollapseExpandFossilBranch(obd_tree, start_time, weight=3.0)
moves[mvi++] = mvNodeTimeSlideUniform(obd_tree, weight=5.0)
moves[mvi++] = mvRootTimeSlideUniform(obd_tree, start_time, weight=2.0)

fossils = obd_tree.getFossils()
for(i in 1:fossils.size())
{
    t[i] := tmrca(obd_tree, clade(fossils[i]))

    a_i = fossils[i].getMinAge()
    b_i = fossils[i].getMaxAge()

    F[i] ~ dnUniform(t[i] - b_i - 0.001, t[i] - a_i + 0.001)
    F[i].clamp( 0 )
}

num_samp_anc := obd_tree.numSampledAncestors();

############################
# Sequence evolution model #
############################

## Strict clock model
branch_rates ~ dnExponential(10.0)
# moves[mvi++] = mvScale(branch_rates, lambda=0.1, weight=2.0, tune=TRUE)

## Nucleotide sequence evolution
sf_hp <- v(1,1,1,1)
sf ~ dnDirichlet(sf_hp)
# moves[mvi++] = mvSimplexElementScale(sf, alpha=100.0, weight=4.0, tune=TRUE)

er_hp <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_hp)
# moves[mvi++] = mvSimplexElementScale(er, alpha=100.0, weight=2.0, tune=TRUE)

Q_seq := fnGTR(er,sf)

alpha_seq ~ dnExponential( 1.0 )
# moves[mvi++] = mvScale(alpha_seq, lambda=1.0,  weight=1.0, tune=TRUE)

rates_seq := fnDiscretizeGamma( alpha_seq, alpha_seq, 4 )

phySeq ~ dnPhyloCTMC(tree=obd_tree, Q=Q_seq, siteRates=rates_seq, branchRates=branch_rates, type="DNA")
phySeq.clamp(sequences)

#################################
# Morphological evolution model #
#################################

## Modeling the Evolution of Binary Morphological Characters

Q_morpho := fnJC(2)

alpha_morpho ~ dnExponential( 1.0 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )
# moves[mvi++] = mvScale(alpha_morpho, lambda=1.0,  weight=1.0, tune=TRUE)

clock_morpho ~ dnExponential(1.0)
# moves[mvi++] = mvScale(clock_morpho, lambda=1.0, weight=1.0, tune=TRUE)

phyMorpho ~ dnPhyloCTMC(tree=obd_tree, siteRates=rates_morpho, branchRates=clock_morpho, Q=Q_morpho, type="Standard")
phyMorpho.clamp(morpho)

#############
# THE Model #
#############

# We define our model.
# We can use any node of our model as a handle, here we chose to use the rate matrix.
mymodel = model(obd_tree)


monitors[1] = mnStochasticVariable(filename="output/mcmc_OBDP_macro_test.out", printgen=1)
monitors[2] = mnFile(filename="output/mcmc_OBDP_macro_test.trees", printgen=1, obd_tree)
monitors[3] = mnScreen(printgen=1, num_samp_anc, start_time)

mymcmc = mcmc(mymodel, monitors, moves, moveschedule="single")
# mymcmc = mcmc(mymodel, monitors, moves)

mymcmc.run(generations=50, tuningInterval=100)

# check the performance of the MCMC/moves
# mymcmc.operatorSummary()

# Read in the tree trace and construct the maximum clade credibility (MCC) tree #
# trace = readTreeTrace("output/mcmc_OBDP_macro_test.trees")

# Summarize tree trace and save MCC tree to file
# mccTree(trace, file="output/mcmc_OBDP_macro_test.tre" )


# you may want to quit RevBayes now
q()
